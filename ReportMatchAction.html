<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BKK BG Rating List</title>
    <!--   <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"> -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
    <style>
        body {
            background-color: #0d0064;
            color: #ffffff;
        }

        h1, h2, h3, h4, h5 {
            color:#61e7ff;
            text-align: center;
        }

        table {
            margin: auto; 
            width: fit-content;
        }

        tr:nth-child(odd) {
            background-color: #1600a8;
        }

        th {
            padding: 3px;
            text-align: center;
            background-color: #0d0064;
            color: #61e7ff;
        }

        td {
            padding: 3px;
        }

        .container {
            margin-top: 15px;
        }
        
        .btn-primary {
            background-color: #0004fd;
            border-color: #1eff29;
            margin-top: 15px;
        }

        .btn-secondary {
            color:#6e6e6e;
            background-color: #0d0064;
            margin-top: 15px;
        }
        
        .input-group-text, .form-select, .form-control {
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            align-items: center;
        }
        .input-group-text {
            flex: 0 0 auto;
        }
        .form-control {
            flex: 1 1 auto;
            flex-shrink: 1; /* Allow the input to shrink */
            min-width: 0; /* Ensure it can shrink to 0 */
        }
        .form-select {
            flex: 0 0 auto;
            white-space: nowrap; /* Prevent the select from shrinking */
        }

        hr.rounded {
            border-top: 8px solid #000;
            border-radius: 5px;
        }

        .centered {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="ratingListTitle">Bangkok BG</h1>

        <!-- Match Report -->
        <h3>Match Report</h3>
        <form id="matchForm">
            <!-- Winner -->
            <div class="input-group">
                <span class="input-group-text" id="winnerLabel">Winner</span>
                <select class="form-select" title="Winner Name" id="winnerName">
                    <option value="Select or edit">Select</option>
                    <option value="Winner">Winner</option>
                </select>
                <input type="text" title="Winner Name" class="form-control" id="winnerNameTyped">
            </div>
            <!-- Loser -->
            <div class="input-group">
                <span class="input-group-text">Loser</span>
                <select class="form-select" title="Loser Name" id="loserName">
                    <option value="Select or edit">Select</option>
                    <option value="Loser">Loser</option>
                </select>
                <input type="text" title="Loser Name" class="form-control" id="loserNameTyped">
            </div>
            <!-- Match Length -->
            <div class="input-group">
                <span class="input-group-text">Match Length</span>
                <select class="form-select" title="Match Length" id="matchLength">
                    <option class="centered" value="1">1</option>
                    <option class="centered" value="3">3</option>
                    <option class="centered" value="5" selected>5</option>
                    <option class="centered" value="7">7</option>
                    <option class="centered" value="9">9</option>
                    <option class="centered" value="11">11</option>
                    <option class="centered" value="13">13</option>
                    <option class="centered" value="15">15</option>
                    <option class="centered" value="17">17</option>
                </select>
                <input type="text" title="Match Length" class="form-control" id="matchLengthTyped" value="">
                <button type="submit" id="submit" class="btn btn-primary float-right">Submit</button>
            </div>
        </form>

        <!-- Submission Status -->
        <h5>Submission Status <button id="updateSubmissionStatus" class="btn-xs btn-secondary">Update</button></h5>
        <div id="statuses">
            <p id="submissionStatus" style="text-align: center"></p>
            <h5 id="runsInfo"></h5>
        </div>


        <!-- Rating List -->
        <hr class="rounded">
        <h3>Rating List <button id="refreshRatingList" class="btn-xs btn-secondary">Refresh</button></h3>
        <div id="ratingList"></div>


        <!-- Ranking Lists -->
        <hr class="rounded">
        <h3>Ranking Lists <button id="fetchMatchList" class="btn-xs btn-secondary">Fetch</button></h3>

        <!-- Played Time Span -->
        <div class="input-group">
            <select class="form-select" title="Ranking List Selection" id="rankingListSelection" onchange="rankingListSelectionChanged()">
                <option class="centered" value="matchesPlayed">Matches Played</option>
                <option class="centered" value="percentMatchesWon">% Matches Won</option>
                <option class="centered" value="currentStreak">Current Streak</option>
                <option class="centered" value="longestWinningStreak">> Winning Streak</option>
                <option class="centered" value="longestLosingStreak">> Losing Streak</option>
                <option class="centered" value="daysInactive">Days Inactive</option>
                <option class="centered" value="playerInfo">Player Info</option>
                <option class="centered" value="rangliste">Rangliste</option>
            </select>
        </div>
        <div class="input-group" id="playerNameInput" style="display:none">
            <select class="form-select" title="Player Name" id="playerName" onchange="playerSelectionChanged()">
                <option value="Select">Select</option>
            </select>
        </div>
        <div class="input-group">
            <select class="form-select" style="flex: 0 0 40%;" title="Interval Selection" id="intervalSelection" onchange="intervalSelectionChanged()">
                <option class="centered" value="Daily">Daily</option>
                <option class="centered" value="Monthly">Monthly</option>
                <option class="centered" value="Yearly">Yearly</option>
                <option class="centered" value="Eternally">Eternally</option>
            </select>
            <select class="form-select" style="flex: 0 0 60%;" title="Played Time Span Selection" id="timeSpanSelection" onchange="playedTimeSpanSelectionChanged()">
                <option class="centered" value="Fetch Matches">Fetch Matches</option>
            </select>
        </div>

        <div id="playedTimeSpanSummary"></div>

        <p style="text-align: center;">
            <button class="btn-xs btn-secondary" id="playedTimeSpanMatchListToggleButton" type="button" data-toggle="collapse" data-target="#playedTimeSpanMatchList" aria-expanded="false" aria-controls="playedTimeSpanMatchList">
                Expand/Collapse Match List
            </button>
        </p>
        <div class="collapse" id="playedTimeSpanMatchList"></div>


        <!-- Settings Section -->
        <div class="container">
            <h3>Settings <button class="btn-xs btn-secondary" id="settingsToggleButton" type="button" data-toggle="collapse" data-target="#settingsSection" aria-expanded="false" aria-controls="settingsSection">
                Expand/Collapse
            </button></h3>
            <div class="collapse" id="settingsSection">
                <div class="input-group">
                    <span class="input-group-text">Your Name</span>
                    <input type="text" class="form-control centered" id="yourNameSetting" placeholder="Enter your name">
                </div>
                <div class="input-group">
                    <span class="input-group-text">Default Interval</span>
                    <input type="text" class="form-control centered" id="defaultIntervalSetting" placeholder="Enter default interval settings">
                </div>
                <p class="centered">MP %MW CS >WS >LS DI PI RL</p>
                <button class="btn btn-primary mt-3" id="saveSettingsButton">Save Settings</button>
            </div>
        </div>


        <!-- Additional Stuff / Rating Formula  / Reporting Guidelines-->
        <hr class="rounded">
        <div id="reportingGuidelines">
            <h3>Connection Issue</h3>
            <p>If you can see this you might have internet connection issues or your access token might be expired.</p>
        </div>
        <div id="reportMatchOnTheWeb"></div>

        <!-- Submission Test -->
        <hr class="rounded">
        <h3>Submission Test</h3>
        <p>To test/exercise match submissions you can change to a Fake Rating List below.
           It should work the same as the BKK BG Rating List, but matches will be cleared from time to time.
           To ensure that test match submissions are not messing up the actual rating list, you can choose fake names like Winner and Loser.
        </p>
        <p>Warning: After this page is refreshed the selection will change back to the actual BKK BG Rating List.</p>
        <div class="input-group">
            <span class="input-group-text">Rating List</span>
            <!-- <input type="text" title="Spacer" class="form-control" id="spacer" value=""> -->
            <select class="form-select" title="Rating List Selection" id="ratingListSelection" onchange="ratingListSelectionChanged()">
                <option value="bkk-bg-rating-list">BKK BG Rating</option>
                <option value="GitHub-Actions">Fake Rating</option>
            </select>
        </div>
        <p><br></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const repoOwner = 'modiholodri';
        const githubToken = '';  // Fill in the token before distributing the file to others

        let oneSecondInterval = setInterval(showSubmissionStatus, 1000);

        let newSubmission = false;
        let anotherSubmissionActive = false;
        let previousRunID = '';

        let latestRunID = '';
        let latestRunConclusion = '';
        let latestRunStatus = '';
        let latestRunUpdatedAt = '';

        // show the submission status when a submission is going on
        function showSubmissionStatus() {
            // show the status of a new submission until the status is Completed
            if (newSubmission) {
                refreshRunsStatus();
                if (latestRunID !== previousRunID) {
                    setRunsInfo(`${latestRunStatus} -> ${latestRunConclusion}`);
                    if (latestRunStatus === 'Completed') {
                        refreshRatingList();
                        fetchMatchList();
                        newSubmission = false;
                        document.getElementById("submit").disabled = false;
                    }
                }
            }

            // show the status of other submissions until the submission is Completed
            if (anotherSubmissionActive) {
                refreshRunsStatus();
                setRunsInfo(`${latestRunID}: ${latestRunStatus} -> ${latestRunConclusion}`);
                if (latestRunStatus === 'Completed') {
                    anotherSubmissionActive = false;
                    document.getElementById("submit").disabled = false;
                }
            }
        }

        // Submit a match report
        document.getElementById('matchForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // get the winner name
            const winnerName = document.getElementById('winnerName').value;
            if (winnerName === 'Select or edit') winnerName = document.getElementById('winnerNameTyped').value;
            
            // get the loser name
            var loserName = document.getElementById('loserName').value;
            if (loserName === 'Select or edit') loserName = document.getElementById('loserNameTyped').value;
            
            // get the match length
            var matchLength = document.getElementById('matchLengthTyped').value;
            if (matchLength === '') matchLength = document.getElementById('matchLength').value;

            const repoName = document.getElementById('ratingListSelection').value;

            if (!winnerName) {
                alert('Select or edit the Winner name!');
            }
            else if (!loserName) {
                alert('Select or edit the Loser name!');
            }
            else if (!githubToken) {
                alert(JSON.stringify({ 
                    event_type: 'match_report', 
                    client_payload: { 
                        winner_name: `${winnerName}`,
                        loser_name:  `${loserName}`, 
                        match_length: `${matchLength}`
                    } 
                }));
            }
            else {
                await refreshRunsStatus();
                setSubmissionStatus(`Submitting match...\n ${winnerName} > ${loserName} -> ${matchLength}`);
                setRunsInfo('Hold on a sec...');
                previousRunID = latestRunID;
                if ( latestRunStatus !== 'Completed') {
                    setSubmissionStatus('Another submission in progress.\nTry again in a few seconds...');
                    anotherSubmissionActive = true;
                    document.getElementById("submit").disabled = true;
                }
                else try {
                    const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/dispatches`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github.v3+json',
                        },
                        body: JSON.stringify({ 
                            event_type: 'match_report', 
                            client_payload: { 
                                winner_name: `${winnerName}`,
                                loser_name:  `${loserName}`, 
                                match_length: `${matchLength}`
                            } 
                        })
                    });

                    newSubmission = true;
                    document.getElementById("submit").disabled = true;

                    // reset the inputs
                    document.getElementById('winnerName').value = 'Select or edit';
                    document.getElementById('winnerNameTyped').value = '';
                    
                    document.getElementById('loserName').value = 'Select or edit';
                    document.getElementById('loserNameTyped').value = '';
                } 
                catch (error) { 
                    // Error triggering GitHub Action: Failed to execute 'json' on 'Response': Unexpected end of JSON input
                    alert('Error triggering GitHub Action: ' + error.message); // Handle error (e.g., notify user, retry, etc.)
                }
            }
        });

        // Fetch the Runs Status
        async function  refreshRunsStatus() {
            const repoName = document.getElementById('ratingListSelection').value;

            try {
                const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/actions/runs?per_page=1&timestamp=${Date.now()}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const workflowRuns = data.workflow_runs;

                // ${run.id} ${run.name} ${run.status} ${run.conclusion} ${run.created_at} ${run.updated_at} ${run.jobs_url}`

                latestRunID = workflowRuns[0].id;
                latestRunStatus = toTitleCase(workflowRuns[0].status.replaceAll('_', ' '));
                
                latestRunUpdatedAt = formatTimestamp(workflowRuns[0].updated_at);
                
                latestRunConclusion = workflowRuns[0].conclusion ? toTitleCase(workflowRuns[0].conclusion.toUpperCase()) : 'Wait...';;
            } 
            catch (error) { 
                alert('Error triggering GitHub Action: ' + error.message); // Handle error (e.g., notify user, retry, etc.)
            }
        }

        // format the UTC time stamp in a nicer way
        const formatTimestamp = (timestamp)=> {
            const datetime = new Date(timestamp)
            const dateString = datetime.toISOString().split('T')[0];
            const timeString = datetime.toTimeString().split(' ')[0];
            return `${dateString} ${timeString}`;
        }

        // Update the Submission Status
        document.getElementById("updateSubmissionStatus").addEventListener("click", async () => {
            await refreshRunsStatus();
            setSubmissionStatus(`Last Submission:\n${latestRunID}: ${latestRunUpdatedAt}`);
            setRunsInfo(`${latestRunStatus} -> ${latestRunConclusion}`);
            document.getElementById("updateSubmissionStatus").blur();
        });

        // Refresh the Rating List
        function refreshRatingList() {
            fetchMarkDownFromRepo('RatingList', 'ratingList');
        }

        // Refresh the Rating List
        document.getElementById('refreshRatingList').onclick = function() {
            refreshRatingList();
        };

        // Set the last Runs Info
        function setRunsInfo (runsInfo) {
            document.getElementById("runsInfo").innerText = runsInfo;
            if (runsInfo.includes('Success')) {
                setSubmissionStatus(document.getElementById("submissionStatus").innerText.replace('Submitting', 'Submitted'));
            }
            document.getElementById("runsInfo").style.color = runsInfo.includes('Success') ? 'green' : runsInfo.includes('Failure') ? 'red' : 'white';
        }

        // Set the Submission Status
        function setSubmissionStatus (submissionStatus) {
            document.getElementById("submissionStatus").innerText = submissionStatus;
        }

        // Convert a string to Title Case
        function toTitleCase(str) {
            return str.replace(
                /\w\S*/g,
                text => text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
            );
        }

        function playedTimeSpanSelectionChanged() {
            populatePlayedTimeSpanMatchList();
        }

        function intervalSelectionChanged() {
            populateTimeSpanSelectionList(matchRecords);
            populatePlayedTimeSpanMatchList();
            rankingListSelectionChanged();
        }

        function playerSelectionChanged() {
            populatePlayerList();
        }

        function rankingListSelectionChanged() {
            // set the played time span match list again, in case it has been overwritten before
            document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playedTimeSpanMatchList);

            switch ( document.getElementById('rankingListSelection').value) {
                case 'percentMatchesWon': 
                    createPercentMatchesWonRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'currentStreak':
                    createCurrentStreakRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'longestWinningStreak':
                    createLongestWinningStreakRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'longestLosingStreak':
                    createLongestLosingStreakRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'matchesPlayed':
                    createMatchesPlayedRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'daysInactive':
                    createLastTimeActiveRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                case 'playerInfo':
                    const yourName = document.getElementById('yourNameSetting').value;
                    if (yourName) {
                        const playerOptions = document.getElementById("playerName").options;
                        for (let i = 0; i < playerOptions.length; i++) {
                            if (playerOptions[i].value === yourName) {
                                playerOptions[i].selected = true;
                                break;
                            }
                        }
                    }
                    summarizeMatchList(playedTimeSpanMatchList);  
                    playerSelectionChanged();
                    break;
                case 'rangliste':
                    createRanglisteRankingList('playedTimeSpanSummary', summarizeMatchList(playedTimeSpanMatchList));
                    break;
                default:
                    break;
            }
        }

        var matchRecords = '';
        var totalMatchList = '';

        // Populate Time Span List
        function populateTimeSpanSelectionList(matchRecords) {
            let interval = document.getElementById("intervalSelection").value;
            const weekday = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
            const month = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
            const intervalLengths = {"Daily":10, "Monthly":7, "Yearly":4, "Eternally":0};
            const selectedIntervalLength = intervalLengths[interval];

            var matchDays = 0;
            var matchTimeSpanOptions = '';

            var lastMatchDate = '';
            var lastMatchID = -1;
            var timeSpanSuffix = '';
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    var matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    const matchID = matchDate.substring(0,selectedIntervalLength);
                    if (matchID != lastMatchID) {
                        matchDays++;
                        const datetime = new Date(matchDate);

                        if (interval === "Daily") {
                            timeSpanSuffix = `${weekday[datetime.getDay()]}`;
                        }
                        else if (interval === "Monthly") {
                            timeSpanSuffix = `${month[datetime.getMonth()]}`;
                        }
                        matchTimeSpanOptions += `<option class="centered" value="${matchID}">${matchID} ${timeSpanSuffix}</option>\n`;
                    }
                    lastMatchID = matchID;
                }
            }
            document.getElementById("timeSpanSelection").innerHTML = matchTimeSpanOptions;

            return matchDays;
        }

        // Fetch the Match List
        function fetchMatchList() {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/MatchList.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    totalMatchList = decodeURIComponent(escape(window.atob( data.content )));

                    matchRecords = totalMatchList.split("\n");
                    
                    if (populateTimeSpanSelectionList(matchRecords) > 0) {
                        populatePlayedTimeSpanMatchList();
                    }
                } else {
                    console.log('Failed to fetch Match List!');
                }
                document.getElementById("fetchMatchList").blur();
            })
            .catch(error => console.error('Error:', error));

            rankingListSelectionChanged();
        }

        // Summarize the Match List
        function summarizeMatchList(matchList) {
            const playerSummary = {};

            var matchRecords = matchList.split("\n");

            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    const matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    const winner = matchInfo[2];
                    const loser = matchInfo[3];
                    const matchLength = matchInfo[4];

                    // Initialize player playerSummary if not already present
                    if (!playerSummary[winner]) {
                        playerSummary[winner] = { played: 0, lastDateActive: '-',
                                                  currentStreak: 0,
                                                  punkte: 0,
                                                  won: 0, currentWon: 0, longestWon: 0, 
                                                  lost: 0, currentLost: 0, longestLost: 0 };
                    }
                    if (!playerSummary[loser]) {
                        playerSummary[loser] = { played: 0, lastDateActive: '-',
                                                 currentStreak: 0,
                                                 punkte: 0,
                                                 won: 0, currentWon: 0, longestWon: 0, 
                                                 lost: 0, currentLost: 0, longestLost: 0 };
                    }
                    
                    // Increment played/won/lost counts
                    const datetime = new Date(matchDate);
                    let bonusPunkte = 1;  // for playing any day
                    if (datetime.getDay() == 3) bonusPunkte = 3;  // for playing on Wednesday
                    else if (datetime.getDay() == 6) bonusPunkte = 5;  // for playing on Saturday

                    // winner
                    playerSummary[winner].played++;
                    playerSummary[winner].won++;
                    playerSummary[winner].currentLost = 0;
                    playerSummary[winner].currentWon++;
                    playerSummary[winner].currentStreak = playerSummary[winner].currentWon;
                    if (playerSummary[winner].currentWon > playerSummary[winner].longestWon) {
                        playerSummary[winner].longestWon = playerSummary[winner].currentWon;
                    }
                    playerSummary[winner].punkte += +matchLength;
                    if (playerSummary[winner].lastDateActive !== matchDate) playerSummary[winner].punkte += bonusPunkte;
                    playerSummary[winner].lastDateActive = matchDate;

                    // loser
                    playerSummary[loser].played++;
                    playerSummary[loser].lost++;
                    playerSummary[loser].currentWon = 0;
                    playerSummary[loser].currentLost++;
                    playerSummary[loser].currentStreak = -playerSummary[loser].currentLost;
                    if (playerSummary[loser].currentLost > playerSummary[loser].longestLost) {
                        playerSummary[loser].longestLost = playerSummary[loser].currentLost;
                    }
                    if (playerSummary[loser].lastDateActive !== matchDate) playerSummary[loser].punkte += bonusPunkte;
                    playerSummary[loser].lastDateActive = matchDate;
                }
            }
            return playerSummary;
        }

        // Create the Player Info
        function createPlayerInfoList(summaryElement, playerSummary, vipPlayerName) {
            var opponentsList = '';
            var vipPlayer = '';
            const opponents = {};

            for (const [player, stats] of Object.entries(playerSummary).sort()) {
                if (player === vipPlayerName) {
                    const winPercentage = Math.round(stats.won*100/stats.played);
                    vipPlayer += `|${player}|${stats.won} - ${stats.lost}|${winPercentage}|${stats.played}|\n`;    
                }
                else {
                    opponents[player] = stats;
                }
            }   

            for (const [player, stats] of Object.entries(opponents).sort((a,b) => (a[1].won/a[1].played)-(b[1].won/b[1].played))) {
                const winPercentage = Math.round(stats.lost*100/stats.played);
                opponentsList += `|${stats.lost} - ${stats.won}|${player}|${winPercentage}|${stats.played}|\n`;
            }

            var playerInfoList = '|   |Result|% Won|Matches|\n|:---:|:---:|:---:|:---:|\n';
            playerInfoList += vipPlayer;
            playerInfoList += `|--------|--------|--------|---|---|\n`;
            playerInfoList += opponentsList;

            document.getElementById(summaryElement).innerHTML = marked.parse(playerInfoList);
        }

        // Percent Matches Played
        function createPercentMatchesWonRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |% Won|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => (b[1].won/b[1].played)-(a[1].won/a[1].played))) {
                const winPercentage = Math.round(stats.won*100/stats.played);
                rankingList += `|${rank++}|${player}|${winPercentage}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Current Streak
        function createCurrentStreakRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Current Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => b[1].currentStreak-a[1].currentStreak)) {
                rankingList += `|${rank++}|${player}|${stats.currentStreak}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }


        // Longest Winning Streak
        function createLongestWinningStreakRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Winning Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => b[1].longestWon-a[1].longestWon)) {
                rankingList += `|${rank++}|${player}|${stats.longestWon}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Longest Losing Streak
        function createLongestLosingStreakRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Losing Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => b[1].longestLost-a[1].longestLost)) {
                rankingList += `|${rank++}|${player}|${stats.longestLost}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Matches Played
        function createMatchesPlayedRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Matches|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => b[1].played-a[1].played)) {
                rankingList += `|${rank++}|${player}|${stats.played}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Create Last Time Active Ranking List
        function createLastTimeActiveRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Idle Days|Date|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => a[1].lastDateActive>b[1].lastDateActive ? -1 : 1)) {
                var today = new Date();
                var lastDateActive = new Date(stats.lastDateActive);
                var timeInMS = today.getTime() - lastDateActive.getTime();
                const inactiveDays = Math.ceil(timeInMS / (1000 * 60 * 60 * 24)) - 1;

                rankingList += `|${rank++}|${player}|${inactiveDays}|${stats.lastDateActive}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Create Rangliste Ranking List
        function createRanglisteRankingList(summaryElement, playerSummary) {
            var rankingList = '|   |   |Punkte|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playerSummary).sort((a,b) => b[1].punkte-a[1].punkte)) {
                rankingList += `|${rank++}|${player}|${stats.punkte}|${stats.won} - ${stats.lost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        var playedTimeSpanMatchList = '';

        // Populate the Played Time Span List
        function populatePlayedTimeSpanMatchList() {
            if (matchRecords.length === 0) {
                alert('Fetch Match List first!');
                return;
            }

            var timeSpanSelection = document.getElementById("timeSpanSelection").value;

            playedTimeSpanMatchList = matchRecords[0] + '\n' + matchRecords[1] + '\n'; // add the table header
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    var matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    if (matchDate.startsWith(timeSpanSelection)) {
                        playedTimeSpanMatchList += `${matchRecords[i]}\n`;
                    }
                }
            }
            document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playedTimeSpanMatchList);

            rankingListSelectionChanged();
        }

        // Populate the Player List
        function populatePlayerList() {
            if (matchRecords.length === 0) {
                alert('Fetch Match List first!');
                return;
            }

            playerName = document.getElementById('playerName').value;
            if (playerName === 'Select or Edit') {
                document.getElementById('playedTimeSpanSummary').innerHTML = '';
                document.getElementById('playedTimeSpanMatchList').innerHTML = '';
                return;
            }

            var timeSpanSelection = document.getElementById("timeSpanSelection").value;

            let matchesPlayed = 0;
            var playerMatchList = matchRecords[0] + '\n' + matchRecords[1] + '\n'; // add the table header
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    const matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    if (matchDate.startsWith(timeSpanSelection)) {
                        const winnerName = matchInfo[2];
                        const loserName = matchInfo[3];
                        if (winnerName === playerName || loserName === playerName) {
                            matchesPlayed++;
                            playerMatchList += `${matchRecords[i]}\n`;
                        }
                    }
                }
            }

            if (matchesPlayed > 0 ) {
                createPlayerInfoList('playedTimeSpanSummary', summarizeMatchList(playerMatchList), playerName);
                document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playerMatchList);
            }
            else {
                document.getElementById('playedTimeSpanSummary').innerHTML = `<div><p class="centered"><br>${playerName} didn't play...</p></div>`;
                document.getElementById('playedTimeSpanMatchList').innerHTML = '';
            }
        }

        // Fetch the Match List
        document.getElementById('fetchMatchList').onclick = function() {
            fetchMatchList();
        }


        // Fetch a markdown file from the repository
        function fetchMarkDownFromRepo(fileName, divName) {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${fileName}.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    const fileContent = decodeURIComponent(escape(window.atob( data.content )));
                    document.getElementById(divName).innerHTML = marked.parse(fileContent);
                } else {
                    console.log(`Failed to fetch file ${fileName}.md!`);
                }
                
                if(fileName === 'RatingList')  {
                    document.getElementById("refreshRatingList").blur();
                }
            })
            .catch(error => console.error('Error:', error));
        }

        // Refresh the Rating List Title
        function refreshRatingListTitle () {
            var sel = document.getElementById('ratingListSelection');
            document.getElementById('ratingListTitle').innerText = sel.options[sel.selectedIndex].text;
        }

        // Clear the Submission Status
        function clearSubmissionStatus() {
            document.getElementById('submissionStatus').innerHTML = '';
            document.getElementById('runsInfo').innerHTML = '';
        }

        // Rating List Selection Changed
        function ratingListSelectionChanged() {
            refreshRatingListTitle();
            refreshRatingList();
            fetchMatchList();
            clearSubmissionStatus();
            fetchFrequentPlayers();
        }

        // Fetch the Frequent Players
        function fetchFrequentPlayers() {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/FrequentPlayers.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    const fileContent = decodeURIComponent(escape(window.atob( data.content )));

                    var frequentPlayers = fileContent.split("\n");
                    var playerOptions = '<option class="centered" value="Select">Select</option>\n';

                    for (var i = 0; i < frequentPlayers.length; i++) {
                        if (frequentPlayers[i].length > 0) {
                            playerOptions += `<option class="centered" value="${frequentPlayers[i]}">${frequentPlayers[i]}</option>\n`;
                        }
                    }
                    document.getElementById("winnerName").innerHTML = playerOptions;
                    document.getElementById("loserName").innerHTML = playerOptions;
                    document.getElementById("playerName").innerHTML = playerOptions;
                } else {
                    console.log('Failed to fetch Frequent Players!');
                }
            })
            .catch(error => console.error('Error:', error));
        }

        // Add DOM Content Loaded Event Listener
        document.addEventListener("DOMContentLoaded", () => {
            refreshRatingListTitle();
            refreshRatingList();
            fetchFrequentPlayers();
            fetchMatchList();

            fetchMarkDownFromRepo('ReportingGuidelines', 'reportingGuidelines');
            fetchMarkDownFromRepo('ReportMatchOnTheWeb', 'reportMatchOnTheWeb');
        });

    </script>
    
    <!-- Bootstrap Expand/Collapse Section -->
    <script>
        // show/hide the player name input
        document.getElementById("rankingListSelection").addEventListener("change", function () {
            const element = document.getElementById("playerNameInput");
            if (this.value === "playerInfo") {
                element.style.display = "flex"; // Show the element
            } else {
                element.style.display = "none"; // Hide the element
            }
        });

        // show/hide the time span match list
        document.getElementById('playedTimeSpanMatchListToggleButton').addEventListener('click', function() {
            var collapseElement = document.getElementById('playedTimeSpanMatchList');
            collapseElement.classList.toggle('show');
        });

        // show/hide the settings section
        document.getElementById('settingsToggleButton').addEventListener('click', function() {
            var collapseElement = document.getElementById('settingsSection');
            collapseElement.classList.toggle('show');
        });

    </script>
        
    <!-- Settings handling -->
    <script>
        // Load settings from localStorage
        function loadSettings() {
            const yourName = localStorage.getItem('yourName') || '';
            const defaultInterval = localStorage.getItem('defaultInterval') || 'D M Y Y Y Y E Y';
            const intervalSelection = localStorage.getItem('intervalSelection') || 'Daily';
            const rankingListSelection = localStorage.getItem('rankingListSelection') || 'matchesPlayed';

            document.getElementById('yourNameSetting').value = yourName;
            document.getElementById('defaultIntervalSetting').value = defaultInterval;
            document.getElementById('intervalSelection').value = intervalSelection;
            document.getElementById('rankingListSelection').value = rankingListSelection;
        }

        document.addEventListener('DOMContentLoaded', loadSettings);

        // Save settings to localStorage
        function saveSettings() {
            const yourName = document.getElementById('yourNameSetting').value;
            const defaultInterval = document.getElementById('defaultIntervalSetting').value;
            const intervalSelection = document.getElementById('intervalSelection').value;
            const rankingListSelection = document.getElementById('rankingListSelection').value;

            localStorage.setItem('yourName', yourName);
            localStorage.setItem('defaultInterval', defaultInterval);
            localStorage.setItem('intervalSelection', intervalSelection);
            localStorage.setItem('rankingListSelection', rankingListSelection);
        }

        // Save the settings when the button is clicked
        document.getElementById('saveSettingsButton').addEventListener('click', () => {
            saveSettings();
        });

        // Save settings to localStorage before the page is unloaded
        window.addEventListener('beforeunload', saveSettings);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js" integrity="sha384-k6d4wzSIapyDyv1kpU366/PK5hCdSbCRGRCMv+eplOQJWyd1fbcAu9OCUj5zNLiq" crossorigin="anonymous"></script>
</body>
</html>
