<!DOCTYPE html>
<html lang="en">
<head>
    <title>Bangkok Backgammon</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="expires" max-age="86400">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            background-color: #0d0064;
            color: #ffffff;
        }

        h1, h2, h3, h4, h5, h6 {
            color:#61e7ff;
            text-align: center;
            margin-top: 15px;
        }

        table {
            margin: auto; 
            width: fit-content;
            margin-top: 15px;
        }

        th {
            padding: 3px;
            text-align: center;
            background-color: #0d0064;
            color: #61e7ff;
        }

        td {
            padding: 3px;
        }

        tr:nth-child(odd) {
            background-color: #1600a8;
        }

        canvas {
            display: block; /* Prevent inline-block spacing issues */
            padding: 0;
            height: auto; /* Adjust height automatically based on content */
        }
        .container-fluid {
            position: relative; 
            width: 100%; 
            margin: 0;
            padding: 0;
        }

        .container {
            margin-top: 15px;
        }
        
        .btn-primary {
            background-color: #0004fd;
            border-color: #1eff29;
            margin-top: 15px;
        }

        .input-group-text, .form-select, .form-control {
            margin-top: 15px;
        }

        .input-group {
            display: flex;
            align-items: center;
        }
        .input-group-text {
            flex: 0 0 auto;
        }
        .form-control {
            flex: 1 1 auto;
            flex-shrink: 1; /* Allow the input to shrink */
            min-width: 0; /* Ensure it can shrink to 0 */
        }
        .form-select {
            flex: 0 0 auto;
            white-space: nowrap; /* Prevent the select from shrinking */
        }

        hr.rounded {
            border-top: 8px solid #000;
            border-radius: 5px;
        }

        .centered {
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="ratingListTitle">Bangkok BG</h1>

        <!-- Match Report -->
        <h3 id="matchReportFormToggleButton" type="button" data-toggle="collapse" data-target="#matchReportForm" aria-expanded="true" aria-controls="matchReportForm">
            Match Report ⇅
        </h3>

        <form id="matchReportForm" class="collapse">
            <!-- Winner -->
            <div class="input-group">
                <span class="input-group-text" id="winnerLabel">Winner</span>
                <select class="form-select" title="Winner Name" id="winnerName">
                    <option value="Select or edit">Select</option>
                    <option value="Winner">Winner</option>
                </select>
                <input type="text" title="Winner Name" class="form-control" id="winnerNameTyped">
            </div>
            <!-- Loser -->
            <div class="input-group">
                <span class="input-group-text">Loser</span>
                <select class="form-select" title="Loser Name" id="loserName">
                    <option value="Select or edit">Select</option>
                    <option value="Loser">Loser</option>
                </select>
                <input type="text" title="Loser Name" class="form-control" id="loserNameTyped">
            </div>
            <!-- Match Length -->
            <div class="input-group">
                <span class="input-group-text">Match Length</span>
                <select class="form-select" title="Match Length" id="matchLength">
                    <option class="centered" value="1">1</option>
                    <option class="centered" value="3">3</option>
                    <option class="centered" value="5" selected>5</option>
                    <option class="centered" value="7">7</option>
                    <option class="centered" value="9">9</option>
                    <option class="centered" value="11">11</option>
                    <option class="centered" value="13">13</option>
                    <option class="centered" value="15">15</option>
                    <option class="centered" value="17">17</option>
                </select>
                <input type="text" title="Match Length" class="form-control" id="matchLengthTyped" value="">
                <button type="submit" id="submit" class="btn btn-primary float-right">Submit</button>
            </div>
            <!-- Submission Status -->
            <h5 id="updateSubmissionStatus" type="button">Submission Status ⟳</h5>
            <div id="statuses">
                <p id="submissionStatus" style="text-align: center"></p>
                <h5 id="runsInfo"></h5>
            </div>
        </form>


        <!-- Rating List -->
        <hr class="rounded">
        <h3 id="ratingListToggleButton" type="button" data-toggle="collapse" data-target="#ratingList" aria-expanded="true" aria-controls="ratingList">
            Rating List ⇅
        </h3>
        <div id="ratingList" class="collapse"></div>


        <!-- Ranking Lists -->
        <hr class="rounded">
        <h3 id="fetchMatchList" type="button">Ranking Lists ⟳</h3>

        <!-- Played Time Span -->
        <div class="input-group">
            <select class="form-select" title="Ranking List Selection" id="rankingListSelection" onchange="rankingListSelectionChanged()">
                <option class="centered" value="matchesPlayed">Matches Played</option>
                <option class="centered" value="percentMatchesWon">% Matches Won</option>
                <option class="centered" value="rangliste">Rangliste</option>
                <option class="centered" value="playerInfo">Player Info</option>
                <option class="centered" value="currentStreak">Current Streak</option>
                <option class="centered" value="longestWinningStreak">> Winning Streak</option>
                <option class="centered" value="longestLosingStreak">> Losing Streak</option>
                <option class="centered" value="daysInactive">Days Inactive</option>
            </select>
        </div>
        <div class="input-group" id="playerNameSelection" style="display:none">
            <select class="form-select" title="Player Name" id="playerName" onchange="playerSelectionChanged()">
                <option value="Select">Select</option>
            </select>
        </div>
        <div class="input-group">
            <select class="form-select" style="flex: 0 0 40%;" title="Interval Selection" id="intervalSelection" onchange="intervalSelectionChanged()">
                <option class="centered" value="Daily">Daily</option>
                <option class="centered" value="Monthly">Monthly</option>
                <option class="centered" value="Yearly">Yearly</option>
                <option class="centered" value="ET">ET</option>
            </select>
            <select class="form-select" style="flex: 0 0 60%;" title="Played Time Span Selection" id="timeSpanSelection" onchange="playedTimeSpanSelectionChanged()">
                <option class="centered" value="Fetch Matches">Fetch Matches</option>
            </select>
        </div>

        <h5 id="rankingChartToggleButton" type="button" data-toggle="collapse" data-target="#rankingChart" aria-expanded="false" aria-controls="rankingChart">
            Ranking Chart ⇅
        </h5>
        <div class="collapse" id="rankingChart">
            <div class="container-fluid" id="ranglistenChartDiv">
                <canvas id="ranglistenChart"></canvas>
            </div>
            <div class="container-fluid" id="matchesStatsChartDiv">
                <canvas id="matchesStatsChart"></canvas>
            </div>
        </div>

        <h5 id="rankingSummaryToggleButton" type="button" data-toggle="collapse" data-target="#playedTimeSpanSummary" aria-expanded="false" aria-controls="playedTimeSpanSummary">
            Ranking Summary ⇅
        </h5>
        <div class="collapse" id="playedTimeSpanSummary"></div>

        <h5 id="playedTimeSpanMatchListToggleButton" type="button" data-toggle="collapse" data-target="#playedTimeSpanMatchList" aria-expanded="false" aria-controls="playedTimeSpanMatchList">
            Match List ⇅
        </h5>
        <div class="collapse" id="playedTimeSpanMatchList"></div>


        <!-- Settings Section -->
        <hr class="rounded">
        <div class="container">
            <h3 id="settingsToggleButton" type="button" data-toggle="collapse" data-target="#settingsSection" aria-expanded="false" aria-controls="settingsSection">
                ⚙ Settings ⇅
            </button></h3>
            <div class="collapse" id="settingsSection">
                <div class="input-group">
                    <span class="input-group-text">Your Name</span>
                    <input type="text" class="form-control centered" id="yourNameSetting" placeholder="Enter your name">
                </div>
                <button class="btn btn-primary mt-3" id="saveSettingsButton">Save Settings</button>
            </div>
        </div>


        <!-- Additional Stuff / Rating Formula  / Reporting Guidelines-->
        <hr class="rounded">
        <div id="reportingGuidelines">
            <h3>Connection Issue</h3>
            <p>If you can see this you might have internet connection issues or your access token might be expired.</p>
        </div>
        <div id="reportMatchOnTheWeb"></div>

        <!-- Submission Test -->
        <hr class="rounded">
        <h3>Submission Test</h3>
        <p>To test/exercise match submissions you can change to a Fake Rating List below.
           It should work the same as the BKK BG Rating List, but matches will be cleared from time to time.
           To ensure that test match submissions are not messing up the actual rating list, you can choose fake names like Winner and Loser.
        </p>
        <p>Warning: After this page is refreshed the selection will change back to the actual BKK BG Rating List.</p>
        <div class="input-group">
            <span class="input-group-text">Rating List</span>
            <!-- <input type="text" title="Spacer" class="form-control" id="spacer" value=""> -->
            <select class="form-select" title="Rating List Selection" id="ratingListSelection" onchange="ratingListSelectionChanged()">
                <option class="centered" value="bkk-bg-rating-list">BKK BG Rating</option>
                <option class="centered" value="GitHub-Actions">Fake Rating</option>
            </select>
        </div>
        <p><br></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const repoOwner = 'modiholodri';
        const githubToken = '';  // Fill in the token before distributing the file to others

        let oneSecondInterval = setInterval(showSubmissionStatus, 1000);

        let newSubmission = false;
        let anotherSubmissionActive = false;
        let previousRunID = '';

        let latestRunID = '';
        let latestRunConclusion = '';
        let latestRunStatus = '';
        let latestRunUpdatedAt = '';

        // show the submission status when a submission is going on
        function showSubmissionStatus() {
            // show the status of a new submission until the status is Completed
            if (newSubmission) {
                refreshRunsStatus();
                if (latestRunID !== previousRunID) {
                    setRunsInfo(`${latestRunStatus} -> ${latestRunConclusion}`);
                    if (latestRunStatus === 'Completed') {
                        refreshRatingList();
                        fetchMatchList();
                        newSubmission = false;
                        document.getElementById("submit").disabled = false;
                    }
                }
            }

            // show the status of other submissions until the submission is Completed
            if (anotherSubmissionActive) {
                refreshRunsStatus();
                setRunsInfo(`${latestRunID}: ${latestRunStatus} -> ${latestRunConclusion}`);
                if (latestRunStatus === 'Completed') {
                    anotherSubmissionActive = false;
                    document.getElementById("submit").disabled = false;
                }
            }
        }

        // Submit a match report
        document.getElementById('matchReportForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // get the winner name
            const winnerName = document.getElementById('winnerName').value;
            if (winnerName === 'Select or edit') winnerName = document.getElementById('winnerNameTyped').value;
            
            // get the loser name
            var loserName = document.getElementById('loserName').value;
            if (loserName === 'Select or edit') loserName = document.getElementById('loserNameTyped').value;
            
            // get the match length
            var matchLength = document.getElementById('matchLengthTyped').value;
            if (matchLength === '') matchLength = document.getElementById('matchLength').value;

            const repoName = document.getElementById('ratingListSelection').value;

            if (!winnerName) {
                alert('Select or edit the Winner name!');
            }
            else if (!loserName) {
                alert('Select or edit the Loser name!');
            }
            else if (!githubToken) {
                alert(JSON.stringify({ 
                    event_type: 'match_report', 
                    client_payload: { 
                        winner_name: `${winnerName}`,
                        loser_name:  `${loserName}`, 
                        match_length: `${matchLength}`
                    } 
                }));
            }
            else {
                await refreshRunsStatus();
                setSubmissionStatus(`Submitting match...\n ${winnerName} > ${loserName} -> ${matchLength}`);
                setRunsInfo('Hold on a sec...');
                previousRunID = latestRunID;
                if ( latestRunStatus !== 'Completed') {
                    setSubmissionStatus('Another submission in progress.\nTry again in a few seconds...');
                    anotherSubmissionActive = true;
                    document.getElementById("submit").disabled = true;
                }
                else try {
                    const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/dispatches`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github.v3+json',
                        },
                        body: JSON.stringify({ 
                            event_type: 'match_report', 
                            client_payload: { 
                                winner_name: `${winnerName}`,
                                loser_name:  `${loserName}`, 
                                match_length: `${matchLength}`
                            } 
                        })
                    });

                    newSubmission = true;
                    document.getElementById("submit").disabled = true;

                    // reset the inputs
                    document.getElementById('winnerName').value = 'Select or edit';
                    document.getElementById('winnerNameTyped').value = '';
                    
                    document.getElementById('loserName').value = 'Select or edit';
                    document.getElementById('loserNameTyped').value = '';
                } 
                catch (error) { 
                    // Error triggering GitHub Action: Failed to execute 'json' on 'Response': Unexpected end of JSON input
                    alert('Error triggering GitHub Action: ' + error.message); // Handle error (e.g., notify user, retry, etc.)
                }
            }
        });

        // Fetch the Runs Status
        async function  refreshRunsStatus() {
            const repoName = document.getElementById('ratingListSelection').value;

            try {
                const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/actions/runs?per_page=1&timestamp=${Date.now()}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                const workflowRuns = data.workflow_runs;

                // ${run.id} ${run.name} ${run.status} ${run.conclusion} ${run.created_at} ${run.updated_at} ${run.jobs_url}`

                latestRunID = workflowRuns[0].id;
                latestRunStatus = toTitleCase(workflowRuns[0].status.replaceAll('_', ' '));
                
                latestRunUpdatedAt = formatTimestamp(workflowRuns[0].updated_at);
                
                latestRunConclusion = workflowRuns[0].conclusion ? toTitleCase(workflowRuns[0].conclusion.toUpperCase()) : 'Wait...';;
            } 
            catch (error) { 
                alert('Error triggering GitHub Action: ' + error.message); // Handle error (e.g., notify user, retry, etc.)
            }
        }

        // format the UTC time stamp in a nicer way
        const formatTimestamp = (timestamp)=> {
            const datetime = new Date(timestamp)
            const dateString = datetime.toISOString().split('T')[0];
            const timeString = datetime.toTimeString().split(' ')[0];
            return `${dateString} ${timeString}`;
        }

        // Refresh the Rating List
        function refreshRatingList() {
            fetchMarkDownFromRepo('RatingList', 'ratingList');
        }

        // Set the last Runs Info
        function setRunsInfo (runsInfo) {
            document.getElementById("runsInfo").innerText = runsInfo;
            if (runsInfo.includes('Success')) {
                setSubmissionStatus(document.getElementById("submissionStatus").innerText.replace('Submitting', 'Submitted'));
            }
            document.getElementById("runsInfo").style.color = runsInfo.includes('Success') ? 'green' : runsInfo.includes('Failure') ? 'red' : 'white';
        }

        // Set the Submission Status
        function setSubmissionStatus (submissionStatus) {
            document.getElementById("submissionStatus").innerText = submissionStatus;
        }

        // Convert a string to Title Case
        function toTitleCase(str) {
            return str.replace(
                /\w\S*/g,
                text => text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
            );
        }

        function playedTimeSpanSelectionChanged() {
            populatePlayedTimeSpanMatchList();
        }

        function intervalSelectionChanged() {
            populateTimeSpanSelectionList(matchRecords);
            populatePlayedTimeSpanMatchList();
            rankingListSelectionChanged();
        }

        function playerSelectionChanged() {
            populatePlayerMatchList();
        }

        function rankingListSelectionChanged() {
            // set the played time span match list again, in case it has been overwritten before
            document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playedTimeSpanMatchList);

            switch ( document.getElementById('rankingListSelection').value) {
                case 'matchesPlayed':
                displayElement('ranglistenChartDiv', false);
                    displayElement('matchesStatsChartDiv', true);
                    createOrUpdateMatchesPlayedChart(playedTimeSpanSummary);
                    createMatchesPlayedRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'percentMatchesWon': 
                displayElement('ranglistenChartDiv', false);
                    displayElement('matchesStatsChartDiv', true);
                    createOrUpdateMatchesPlayedChart(playedTimeSpanSummary);
                    createPercentMatchesWonRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'rangliste':
                    displayElement('ranglistenChartDiv', true);
                    displayElement('matchesStatsChartDiv', false);
                    createOrUpdateRanglistenChart(playedTimeSpanSummary);

                    createRanglisteRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'playerInfo':
                    playerSelectionChanged();
                    break;
                case 'currentStreak':
                    createCurrentStreakRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'longestWinningStreak':
                    createLongestWinningStreakRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'longestLosingStreak':
                    createLongestLosingStreakRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                case 'daysInactive':
                    createLastTimeActiveRankingList('playedTimeSpanSummary', playedTimeSpanSummary);
                    break;
                default:
                    break;
            }
        }

        function selectDefaultPlayer() {
            const yourName = document.getElementById('yourNameSetting').value;
            if (yourName) {
                const playerOptions = document.getElementById("playerName").options;
                for (let i = 0; i < playerOptions.length; i++) {
                    if (playerOptions[i].value === yourName) {
                        playerOptions[i].selected = true;
                        break;
                    }
                }
                if ( document.getElementById('rankingListSelection').value === 'playerInfo') {
                    playerSelectionChanged();
                }
            }
        }

        var matchRecords = '';
        var totalMatchList = '';

        // Populate Time Span List
        function populateTimeSpanSelectionList(matchRecords) {
            let interval = document.getElementById("intervalSelection").value;
            const weekday = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
            const month = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
            const intervalLengths = {"Daily":10, "Monthly":7, "Yearly":4, "ET":0};
            const selectedIntervalLength = intervalLengths[interval];

            var matchDays = 0;
            var matchTimeSpanOptions = '';

            var lastMatchDate = '';
            var lastMatchID = -1;
            var timeSpanSuffix = '';
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    var matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    const matchID = matchDate.substring(0,selectedIntervalLength);
                    if (matchID != lastMatchID) {
                        matchDays++;
                        const datetime = new Date(matchDate);

                        if (interval === "Daily") {
                            timeSpanSuffix = `${weekday[datetime.getDay()]}`;
                        }
                        else if (interval === "Monthly") {
                            timeSpanSuffix = `${month[datetime.getMonth()]}`;
                        }
                        matchTimeSpanOptions += `<option class="centered" value="${matchID}">${matchID} ${timeSpanSuffix}</option>\n`;
                    }
                    lastMatchID = matchID;
                }
            }
            document.getElementById("timeSpanSelection").innerHTML = matchTimeSpanOptions;

            return matchDays;
        }

        // Fetch the Match List
        function fetchMatchList() {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/MatchList.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    totalMatchList = decodeURIComponent(escape(window.atob( data.content )));

                    matchRecords = totalMatchList.split("\n");
                    
                    if (populateTimeSpanSelectionList(matchRecords) > 0) {
                        populatePlayedTimeSpanMatchList();
                    }
                } else {
                    console.log('Failed to fetch Match List!');
                }
            })
            .catch(error => console.error('Error:', error));

            rankingListSelectionChanged();
        }


        var playedTimeSpanSummary = {};
        // Summarize the Match List
        function summarizeMatchList(matchList) {
            const matchListSummary = {};
            var matchRecords = matchList.split("\n");

            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    const matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    const winner = matchInfo[2];
                    const loser = matchInfo[3];
                    const matchLength = matchInfo[4];

                    // Initialize player matchListSummary if not already present
                    if (!matchListSummary[winner]) {
                        matchListSummary[winner] = { lastDateActive: '-',
                                                     matchesPlayed: 0, matchesWon: 0, matchesLost: 0, 
                                                     punkte: 0, punkteWon: 0, punkteLost: 0, punkteBonus: 0,
                                                     currentStreak: 0,
                                                     currentWon: 0, longestWon: 0, 
                                                     currentLost: 0, longestLost: 0 };
                    }
                    if (!matchListSummary[loser]) {
                        matchListSummary[loser] = { lastDateActive: '-',
                                                    matchesPlayed: 0, matchesWon: 0, matchesLost: 0, 
                                                    punkte: 0, punkteWon: 0, punkteLost: 0, punkteBonus: 0,
                                                    currentStreak: 0,
                                                    currentWon: 0, longestWon: 0, 
                                                    currentLost: 0, longestLost: 0 };
                    }
                    
                    // Increment played/won/lost counts
                    const datetime = new Date(matchDate);
                    const isSaturday = datetime.getDay() == 6;
                    let bonusPunkte = isSaturday ? 5 : 0;  // for playing on Saturday

                    // winner
                    matchListSummary[winner].matchesPlayed++;
                    matchListSummary[winner].matchesWon++;

                    if (isSaturday) {
                        matchListSummary[winner].punkte += +matchLength;
                        matchListSummary[winner].punkteWon += +matchLength;
                        if (matchListSummary[winner].lastDateActive !== matchDate) {
                            matchListSummary[winner].punkte += bonusPunkte;
                            matchListSummary[winner].punkteBonus += bonusPunkte;
                        }
                    }
                    matchListSummary[winner].lastDateActive = matchDate;

                    matchListSummary[winner].currentLost = 0;
                    matchListSummary[winner].currentWon++;
                    matchListSummary[winner].currentStreak = matchListSummary[winner].currentWon;
                    if (matchListSummary[winner].currentWon > matchListSummary[winner].longestWon) {
                        matchListSummary[winner].longestWon = matchListSummary[winner].currentWon;
                    }
                    if (matchListSummary[winner].lastDateActive !== matchDate) matchListSummary[winner].punkte += bonusPunkte;

                    // loser
                    matchListSummary[loser].matchesPlayed++;
                    matchListSummary[loser].matchesLost++;

                    if (isSaturday) {
                        matchListSummary[loser].punkteLost += +matchLength;
                        if (matchListSummary[loser].lastDateActive !== matchDate) {
                            matchListSummary[loser].punkte += bonusPunkte;
                            matchListSummary[loser].punkteBonus += bonusPunkte;
                        }
                    }
                    matchListSummary[loser].lastDateActive = matchDate;

                    matchListSummary[loser].currentWon = 0;
                    matchListSummary[loser].currentLost++;
                    matchListSummary[loser].currentStreak = -matchListSummary[loser].currentLost;
                    if (matchListSummary[loser].currentLost > matchListSummary[loser].longestLost) {
                        matchListSummary[loser].longestLost = matchListSummary[loser].currentLost;
                    }
                    if (matchListSummary[loser].lastDateActive !== matchDate) matchListSummary[loser].punkte += bonusPunkte;
                    matchListSummary[loser].lastDateActive = matchDate;
                }
            }
            return matchListSummary;
        }

        // Create the Player Info
        function createPlayerInfoList(summaryElement, playerSummary, vipPlayerName) {
            var opponentsList = '';
            var vipPlayer = '';
            const opponents = {};

            for (const [player, stats] of Object.entries(playerSummary).sort()) {
                if (player === vipPlayerName) {
                    const winPercentage = Math.round(stats.matchesWon*100/stats.matchesPlayed);
                    vipPlayer += `|${player}|${stats.matchesWon} - ${stats.matchesLost}|${winPercentage}|${stats.matchesPlayed}|\n`;    
                }
                else {
                    opponents[player] = stats;
                }
            }   

            for (const [player, stats] of Object.entries(opponents).sort((a,b) => (a[1].matchesWon/a[1].matchesPlayed)-(b[1].matchesWon/b[1].matchesPlayed))) {
                const winPercentage = Math.round(stats.matchesLost*100/stats.matchesPlayed);
                opponentsList += `|${stats.matchesLost} - ${stats.matchesWon}|${player}|${winPercentage}|${stats.matchesPlayed}|\n`;
            }

            var playerInfoList = '|   |    |% Won|Matches|\n|:---:|:---:|:---:|:---:|\n';
            playerInfoList += vipPlayer;
            playerInfoList += `|--------|--------|--------|---|---|\n`;
            playerInfoList += opponentsList;

            document.getElementById(summaryElement).innerHTML = marked.parse(playerInfoList);
        }

        // Percent Matches Played
        function createPercentMatchesWonRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |% Won|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => (b[1].matchesWon/b[1].matchesPlayed)-(a[1].matchesWon/a[1].matchesPlayed))) {
                const winPercentage = Math.round(stats.matchesWon*100/stats.matchesPlayed);
                rankingList += `|${rank++}|${player}|${winPercentage}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Current Streak
        function createCurrentStreakRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Current Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => b[1].currentStreak-a[1].currentStreak)) {
                rankingList += `|${rank++}|${player}|${stats.currentStreak}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }


        // Longest Winning Streak
        function createLongestWinningStreakRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Winning Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => b[1].longestWon-a[1].longestWon)) {
                rankingList += `|${rank++}|${player}|${stats.longestWon}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Longest Losing Streak
        function createLongestLosingStreakRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Losing Streak|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => b[1].longestLost-a[1].longestLost)) {
                rankingList += `|${rank++}|${player}|${stats.longestLost}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Matches Played
        function createMatchesPlayedRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Matches|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => b[1].matchesPlayed-a[1].matchesPlayed)) {
                rankingList += `|${rank++}|${player}|${stats.matchesPlayed}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Create Last Time Active Ranking List
        function createLastTimeActiveRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Idle Days|Date|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => a[1].lastDateActive>b[1].lastDateActive ? -1 : 1)) {
                var today = new Date();
                var lastDateActive = new Date(stats.lastDateActive);
                var timeInMS = today.getTime() - lastDateActive.getTime();
                const inactiveDays = Math.ceil(timeInMS / (1000 * 60 * 60 * 24)) - 1;

                rankingList += `|${rank++}|${player}|${inactiveDays}|${stats.lastDateActive}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        // Create Rangliste Ranking List
        function createRanglisteRankingList(summaryElement, playedTimeSpanSummary) {
            var rankingList = '|   |   |Punkte|Result|\n|:---:|:---:|:---:|:---:|\n';

            var rank = 1;
            for (const [player, stats] of Object.entries(playedTimeSpanSummary).sort((a,b) => b[1].punkte-a[1].punkte)) {
                rankingList += `|${rank++}|${player}|${stats.punkte}|${stats.matchesWon} - ${stats.matchesLost}|\n`;
            }   
            document.getElementById(summaryElement).innerHTML = marked.parse(rankingList);
        }

        var playedTimeSpanMatchList = '';

        // Populate the Played Time Span List
        function populatePlayedTimeSpanMatchList() {
            if (matchRecords.length === 0) {
                return;
            }

            var timeSpanSelection = document.getElementById("timeSpanSelection").value;
            let gotMatches = false
            playedTimeSpanMatchList = matchRecords[0] + '\n' + matchRecords[1] + '\n'; // add the table header
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    var matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    if (matchDate.startsWith(timeSpanSelection)) {
                        playedTimeSpanMatchList += `${matchRecords[i]}\n`;
                        gotMatches = true
                    }
                    else if (gotMatches) break;
                }
            }
            document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playedTimeSpanMatchList);
            playedTimeSpanSummary = summarizeMatchList(playedTimeSpanMatchList);

            rankingListSelectionChanged();
        }

        // Populate the Player Match List
        function populatePlayerMatchList() {
            if (matchRecords.length === 0) {
                return;
            }

            playerName = document.getElementById('playerName').value;
            if (playerName === 'Select or Edit') {
                document.getElementById('playedTimeSpanSummary').innerHTML = '';
                document.getElementById('playedTimeSpanMatchList').innerHTML = '';
                return;
            }

            var timeSpanSelection = document.getElementById("timeSpanSelection").value;

            let matchesPlayed = 0;
            var playerMatchList = matchRecords[0] + '\n' + matchRecords[1] + '\n'; // add the table header
            for (var i = matchRecords.length-1; i > 1; i--) {
                if (matchRecords[i].length > 0) {
                    const matchInfo = matchRecords[i].split('|');
                    const matchDate = matchInfo[1];
                    if (matchDate.startsWith(timeSpanSelection)) {
                        const winnerName = matchInfo[2];
                        const loserName = matchInfo[3];
                        if (winnerName === playerName || loserName === playerName) {
                            matchesPlayed++;
                            playerMatchList += `${matchRecords[i]}\n`;
                        }
                    }
                }
            }

            if (matchesPlayed > 0 ) {
                createPlayerInfoList('playedTimeSpanSummary', summarizeMatchList(playerMatchList), playerName);
                document.getElementById('playedTimeSpanMatchList').innerHTML = marked.parse(playerMatchList);
            }
            else {
                document.getElementById('playedTimeSpanSummary').innerHTML = `<div><p class="centered"><br>${playerName} didn't play...</p></div>`;
                document.getElementById('playedTimeSpanMatchList').innerHTML = '';
            }
        }


        // Fetch a markdown file from the repository
        function fetchMarkDownFromRepo(fileName, divName) {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${fileName}.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    const fileContent = decodeURIComponent(escape(window.atob( data.content )));
                    document.getElementById(divName).innerHTML = marked.parse(fileContent);
                } else {
                    console.log(`Failed to fetch file ${fileName}.md!`);
                }
            })
            .catch(error => console.error('Error:', error));
        }

        // Refresh the Rating List Title
        function refreshRatingListTitle () {
            var sel = document.getElementById('ratingListSelection');
            document.getElementById('ratingListTitle').innerText = sel.options[sel.selectedIndex].text;
        }

        // Clear the Submission Status
        function clearSubmissionStatus() {
            document.getElementById('submissionStatus').innerHTML = '';
            document.getElementById('runsInfo').innerHTML = '';
        }

        // Rating List Selection Changed
        function ratingListSelectionChanged() {
            refreshRatingListTitle();
            refreshRatingList();
            fetchMatchList();
            clearSubmissionStatus();
            fetchFrequentPlayers();
        }

        // Fetch the Frequent Players
        function fetchFrequentPlayers() {
            const repoName = document.getElementById('ratingListSelection').value;
            const url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/FrequentPlayers.md?timestamp=${Date.now()}`;

            const options = {
                headers: {
                    'Authorization': `token ${githubToken}`
                }
            };

            fetch(url, options)
            .then(response => response.json())
            .then(data => {
                if (data.content) {
                    const fileContent = decodeURIComponent(escape(window.atob( data.content )));

                    var frequentPlayers = fileContent.split("\n");
                    var playerOptions = '<option class="centered" value="Select">Select</option>\n';

                    for (var i = 0; i < frequentPlayers.length; i++) {
                        if (frequentPlayers[i].length > 0) {
                            playerOptions += `<option class="centered" value="${frequentPlayers[i]}">${frequentPlayers[i]}</option>\n`;
                        }
                    }
                    document.getElementById("winnerName").innerHTML = playerOptions;
                    document.getElementById("loserName").innerHTML = playerOptions;
                    document.getElementById("playerName").innerHTML = playerOptions;
                    selectDefaultPlayer();
                } else {
                    console.log('Failed to fetch Frequent Players!');
                }
            })
            .catch(error => console.error('Error:', error));
        }

        // Add DOM Content Loaded Event Listener
        document.addEventListener("DOMContentLoaded", () => {
            fetchFrequentPlayers();
            refreshRatingListTitle();
            refreshRatingList();
            fetchMatchList();

            fetchMarkDownFromRepo('ReportingGuidelines', 'reportingGuidelines');
            fetchMarkDownFromRepo('ReportMatchOnTheWeb', 'reportMatchOnTheWeb');
        });

    </script>
    
    <!-- Events Section -->
    <script>
        // Update the Submission Status
        document.getElementById("updateSubmissionStatus").addEventListener("click", async () => {
            await refreshRunsStatus();
            setSubmissionStatus(`Last Submission:\n${latestRunID}: ${latestRunUpdatedAt}`);
            setRunsInfo(`${latestRunStatus} -> ${latestRunConclusion}`);
        });

        // Fetch the Match List
        document.getElementById('fetchMatchList').onclick = function() {
            fetchMatchList();
        }

        // show/hide the match report form
        document.getElementById('matchReportFormToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('matchReportForm');
            collapseElement.classList.toggle('show');
        });

        // show/hide the Rating List
        document.getElementById('ratingListToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('ratingList');
            collapseElement.classList.toggle('show');
        });

        // show/hide the player name input
        document.getElementById("rankingListSelection").addEventListener("change", function () {
            const element = document.getElementById("playerNameSelection");
            this.value === "playerInfo" ? element.style.display = "flex" : element.style.display = "none";
        });

        // show/hide the Ranking Chart
        document.getElementById('rankingChartToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('rankingChart');
            collapseElement.classList.toggle('show');
        });

        // show/hide the Ranking Summary
        document.getElementById('rankingSummaryToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('playedTimeSpanSummary');
            collapseElement.classList.toggle('show');
        });

        // show/hide the time span Match List
        document.getElementById('playedTimeSpanMatchListToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('playedTimeSpanMatchList');
            collapseElement.classList.toggle('show');
        });

        function displayElement(elementName, showElement) {
            const element = document.getElementById(elementName);
            if (showElement) {
                element.style.display = "flex"; // Show the element
            } else {
                element.style.display = "none"; // Hide the element
            }
        }

        // show/hide the settings section
        document.getElementById('settingsToggleButton').addEventListener('click', function() {
            const collapseElement = document.getElementById('settingsSection');
            collapseElement.classList.toggle('show');
        });

    </script>
        
    <!-- Settings handling -->
    <script>
        // Load settings from localStorage
        function loadSettings() {
            // Match Report Form Collapse State
            const matchReportFormState = localStorage.getItem('matchReportFormState') || 'expanded';
            const matchReportForm = document.getElementById('matchReportForm');
            matchReportFormState === 'expanded' ? matchReportForm.classList.add('show') : matchReportForm.classList.remove('show');

            // Match Report Form Collapse State
            const ratingListState = localStorage.getItem('matchReportFormState') || 'expanded';
            const ratingList = document.getElementById('ratingList');
            ratingListState === 'expanded' ? ratingList.classList.add('show') : ratingList.classList.remove('show');

            // Ranking List Selection
            const rankingListSelection = localStorage.getItem('rankingListSelection') || 'matchesPlayed';
            document.getElementById('rankingListSelection').value = rankingListSelection;

            // Player Name Selection
            const yourName = localStorage.getItem('yourName') || '';
            document.getElementById('yourNameSetting').value = yourName;

            // Expand/Collapse the Player Name Selection depending on the Ranking List Selection
            const element = document.getElementById("playerNameSelection");
            if (rankingListSelection === "playerInfo") {
                element.style.display = "flex"; // Show the element
            } else {
                element.style.display = "none"; // Hide the element
            }

            // Interval Selection
            const intervalSelection = localStorage.getItem('intervalSelection') || 'Daily';
            document.getElementById('intervalSelection').value = intervalSelection;

            // Ranking Chart Collapse State
            const rankingChartState = localStorage.getItem('rankingChartState') || 'expanded';
            const rankingChart = document.getElementById('rankingChart');
            rankingChartState === 'expanded' ? rankingChart.classList.add('show') : rankingChart.classList.remove('show');

            // Ranking Summary Collapse State
            const rankingSummaryState = localStorage.getItem('rankingSummaryState') || 'collapsed';
            const rankingSummary = document.getElementById('playedTimeSpanSummary');
            rankingSummaryState === 'expanded' ? rankingSummary.classList.add('show') : rankingSummary.classList.remove('show');
        }

        // load the settings once the DOM is ready
        document.addEventListener('DOMContentLoaded', loadSettings);

        // Save settings to localStorage
        function saveSettings() {
            // Match Report Form Collapse State
            const matchReportFormCollapsed = document.getElementById('matchReportForm').classList.contains('show') ? 'expanded' : 'collapsed';
            localStorage.setItem('matchReportFormState', matchReportFormCollapsed);

            // Rating List Form Collapse State
            const ratingListCollapsed = document.getElementById('ratingList').classList.contains('show') ? 'expanded' : 'collapsed';
            localStorage.setItem('ratingListState', ratingListCollapsed);

            // Ranking List Selection
            const rankingListSelection = document.getElementById('rankingListSelection').value;
            localStorage.setItem('rankingListSelection', rankingListSelection);

            // Player Name Selection
            const yourName = document.getElementById('yourNameSetting').value;
            localStorage.setItem('yourName', yourName);

            // Interval Selection
            const intervalSelection = document.getElementById('intervalSelection').value;
            localStorage.setItem('intervalSelection', intervalSelection);

            // Ranking Chart Collapse State
            const rankingChartCollapsed = document.getElementById('rankingChart').classList.contains('show') ? 'expanded' : 'collapsed';
            localStorage.setItem('rankingChartState', rankingChartCollapsed);

            // Ranking Summary Collapse State
            const rankingSummaryCollapsed = document.getElementById('playedTimeSpanSummary').classList.contains('show') ? 'expanded' : 'collapsed';
            localStorage.setItem('rankingSummaryState', rankingSummaryCollapsed);
        }

        // Save the settings when the button is clicked
        document.getElementById('saveSettingsButton').addEventListener('click', () => {
            saveSettings();
        });

        // Save settings to localStorage before the page is unloaded
        window.addEventListener('beforeunload', saveSettings);
    </script>

    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        // If the chart already exists, destroy it before creating a new one
        function destroyChart(chart) {
            if (chart) {
                chart.destroy();
                chart = null;
            }
        }

        // Dynamically adjust canvas height based on the number of players
        function optimizeChartHeight(chartName, numberOfPlayers) {
            const heightPerPlayer = 20; // Height per player in pixels
            const additionalHeight = 100;
            const minHeight = additionalHeight + heightPerPlayer; // Minimum height for the canvas
            const calculatedHeight = Math.max(numberOfPlayers * heightPerPlayer + additionalHeight, minHeight);

            document.getElementById(chartName).height = calculatedHeight;
        }
        
        // Function to create or update the Matches chart
        let matchesStatsChart;
        function createOrUpdateMatchesPlayedChart(matchListSummary) {
            const ctx = document.getElementById('matchesStatsChart').getContext('2d');

            // Extract data for the chart
            const players = document.getElementById('rankingListSelection').value === 'matchesPlayed' ?
                            Object.keys(matchListSummary).sort((a, b) => matchListSummary[b].matchesPlayed - matchListSummary[a].matchesPlayed) :
                            Object.keys(matchListSummary).sort((a, b) => (matchListSummary[b].matchesWon/matchListSummary[b].matchesPlayed)-(matchListSummary[a].matchesWon/matchListSummary[a].matchesPlayed));
            if (players.length < 1) return;
            const matchesWon = players.map(player => matchListSummary[player].matchesWon);
            const matchesLost = players.map(player => matchListSummary[player].matchesLost);

            destroyChart(matchesStatsChart);
            optimizeChartHeight('matchesStatsChart', players.length);

            // Create the chart if it doesn't exist
            matchesStatsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: players, // Player names
                    datasets: [
                        {
                            label: 'Won',
                            data: matchesWon,
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Lost',
                            data: matchesLost,
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    indexAxis: 'y', // Set the chart to horizontal
                    responsive: true,
                    maintainAspectRatio: false, // Allow the chart to resize freely
                    plugins: {
                        legend: {
                            position: 'bottom',
                        },
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            stacked: true,
                            position: 'top', // Move the axis label to the top
                            title: {
                                display: true,
                                text: 'Matches',
                            },
                        },
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                autoSkip: false
                            },
                        }
                    }
                }
            });
        }

        // Function to create or update the Ranglisten chart
        let ranglistenChart;
        function createOrUpdateRanglistenChart(matchListSummary) {
            const ctx = document.getElementById('ranglistenChart').getContext('2d');

            // Extract data for the chart
            const players = Object.keys(matchListSummary).sort((a, b) => matchListSummary[b].punkte - matchListSummary[a].punkte);
            if (players.length < 1) return;
            const punkteWon = players.map(player => matchListSummary[player].punkteWon);
            const punkteBonus = players.map(player => matchListSummary[player].punkteBonus);
            const punkteLost = players.map(player => matchListSummary[player].punkteLost);

            destroyChart(ranglistenChart);
            optimizeChartHeight('ranglistenChart', players.length);

            // Create the chart
            ranglistenChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: players, // Player names
                    datasets: [
                        {
                            label: 'Won',
                            data: punkteWon,
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Bonus',
                            data: punkteBonus,
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Lost',
                            hidden: true,
                            data: punkteLost,
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    indexAxis: 'y', // Set the chart to horizontal
                    responsive: true,
                    maintainAspectRatio: false, // Allow the chart to resize freely
                    plugins: {
                        legend: {
                            position: 'bottom',
                        },
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            stacked: true,
                            position: 'top',
                            title: {
                                display: true,
                                text: 'Punkte',
                            },
                        },
                        y: {
                            beginAtZero: true,
                            stacked: true,
                            ticks: {
                                autoSkip:false
                            }
                        }
                    }
                }
            });
        }

    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js" integrity="sha384-k6d4wzSIapyDyv1kpU366/PK5hCdSbCRGRCMv+eplOQJWyd1fbcAu9OCUj5zNLiq" crossorigin="anonymous"></script>
</body>
</html>
